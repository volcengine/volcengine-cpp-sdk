/*
* Code generated by Beijing Volcanoengine Technology.Do NOT EDIT.
* Copyright Beijing Volcanoengine Technology Ltd All rights reserved.
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
*      http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
*/
#pragma once
#include <volcengine/core/VolcengineClient.h>
#include "volcengine/vke/VkeClient.h"

using namespace volcengine;
using namespace volcengine::vke;

VkeClient::VkeClient(const std::shared_ptr<VolcengineClientConfig> &config) {
    client_ = std::make_shared<VolcengineClient>(config);
}


ResultData<VolcengineMetadata, CreateAddonResult> VkeClient::CreateAddon(const CreateAddonRequest &input) const{
    ResultData<VolcengineMetadata, CreateAddonResult> result;
    auto rb = client_->initBuilder(svc_);
    rb = input.withRequestBuilder(rb,"");
    auto headers = rb.getHeaders();
    headers["content-type"] = "application/json";
    rb.setHeaders(headers);

    auto content = std::make_shared<std::stringstream>();
    std::string body;
    if (!input.jsonPayload().empty()){
        body = input.jsonPayload().dump();
        *content << body;
    }else{
        content = nullptr;
    }

    auto req = rb.Build(MethodPost, content,body);
    auto resp = client_->doCall(req);
    result.setMetadata(resp.getMetadata());
    if (!resp.isSuccess()) {
        result.setSuccess(false);
        return result;
    }
    auto output = std::make_shared<CreateAddonResult>();
    output->fromJsonString(resp.getResult()->getResponseBody());
    result.setSuccess(true);
    result.setResult(output);
    return result;
}

ResultData<VolcengineMetadata, CreateClusterResult> VkeClient::CreateCluster(const CreateClusterRequest &input) const{
    ResultData<VolcengineMetadata, CreateClusterResult> result;
    auto rb = client_->initBuilder(svc_);
    rb = input.withRequestBuilder(rb,"");
    auto headers = rb.getHeaders();
    headers["content-type"] = "application/json";
    rb.setHeaders(headers);

    auto content = std::make_shared<std::stringstream>();
    std::string body;
    if (!input.jsonPayload().empty()){
        body = input.jsonPayload().dump();
        *content << body;
    }else{
        content = nullptr;
    }

    auto req = rb.Build(MethodPost, content,body);
    auto resp = client_->doCall(req);
    result.setMetadata(resp.getMetadata());
    if (!resp.isSuccess()) {
        result.setSuccess(false);
        return result;
    }
    auto output = std::make_shared<CreateClusterResult>();
    output->fromJsonString(resp.getResult()->getResponseBody());
    result.setSuccess(true);
    result.setResult(output);
    return result;
}

ResultData<VolcengineMetadata, CreateDefaultNodePoolResult> VkeClient::CreateDefaultNodePool(const CreateDefaultNodePoolRequest &input) const{
    ResultData<VolcengineMetadata, CreateDefaultNodePoolResult> result;
    auto rb = client_->initBuilder(svc_);
    rb = input.withRequestBuilder(rb,"");
    auto headers = rb.getHeaders();
    headers["content-type"] = "application/json";
    rb.setHeaders(headers);

    auto content = std::make_shared<std::stringstream>();
    std::string body;
    if (!input.jsonPayload().empty()){
        body = input.jsonPayload().dump();
        *content << body;
    }else{
        content = nullptr;
    }

    auto req = rb.Build(MethodPost, content,body);
    auto resp = client_->doCall(req);
    result.setMetadata(resp.getMetadata());
    if (!resp.isSuccess()) {
        result.setSuccess(false);
        return result;
    }
    auto output = std::make_shared<CreateDefaultNodePoolResult>();
    output->fromJsonString(resp.getResult()->getResponseBody());
    result.setSuccess(true);
    result.setResult(output);
    return result;
}

ResultData<VolcengineMetadata, CreateKubeconfigResult> VkeClient::CreateKubeconfig(const CreateKubeconfigRequest &input) const{
    ResultData<VolcengineMetadata, CreateKubeconfigResult> result;
    auto rb = client_->initBuilder(svc_);
    rb = input.withRequestBuilder(rb,"");
    auto headers = rb.getHeaders();
    headers["content-type"] = "application/json";
    rb.setHeaders(headers);

    auto content = std::make_shared<std::stringstream>();
    std::string body;
    if (!input.jsonPayload().empty()){
        body = input.jsonPayload().dump();
        *content << body;
    }else{
        content = nullptr;
    }

    auto req = rb.Build(MethodPost, content,body);
    auto resp = client_->doCall(req);
    result.setMetadata(resp.getMetadata());
    if (!resp.isSuccess()) {
        result.setSuccess(false);
        return result;
    }
    auto output = std::make_shared<CreateKubeconfigResult>();
    output->fromJsonString(resp.getResult()->getResponseBody());
    result.setSuccess(true);
    result.setResult(output);
    return result;
}

ResultData<VolcengineMetadata, CreateNodePoolResult> VkeClient::CreateNodePool(const CreateNodePoolRequest &input) const{
    ResultData<VolcengineMetadata, CreateNodePoolResult> result;
    auto rb = client_->initBuilder(svc_);
    rb = input.withRequestBuilder(rb,"");
    auto headers = rb.getHeaders();
    headers["content-type"] = "application/json";
    rb.setHeaders(headers);

    auto content = std::make_shared<std::stringstream>();
    std::string body;
    if (!input.jsonPayload().empty()){
        body = input.jsonPayload().dump();
        *content << body;
    }else{
        content = nullptr;
    }

    auto req = rb.Build(MethodPost, content,body);
    auto resp = client_->doCall(req);
    result.setMetadata(resp.getMetadata());
    if (!resp.isSuccess()) {
        result.setSuccess(false);
        return result;
    }
    auto output = std::make_shared<CreateNodePoolResult>();
    output->fromJsonString(resp.getResult()->getResponseBody());
    result.setSuccess(true);
    result.setResult(output);
    return result;
}

ResultData<VolcengineMetadata, CreateNodesResult> VkeClient::CreateNodes(const CreateNodesRequest &input) const{
    ResultData<VolcengineMetadata, CreateNodesResult> result;
    auto rb = client_->initBuilder(svc_);
    rb = input.withRequestBuilder(rb,"");
    auto headers = rb.getHeaders();
    headers["content-type"] = "application/json";
    rb.setHeaders(headers);

    auto content = std::make_shared<std::stringstream>();
    std::string body;
    if (!input.jsonPayload().empty()){
        body = input.jsonPayload().dump();
        *content << body;
    }else{
        content = nullptr;
    }

    auto req = rb.Build(MethodPost, content,body);
    auto resp = client_->doCall(req);
    result.setMetadata(resp.getMetadata());
    if (!resp.isSuccess()) {
        result.setSuccess(false);
        return result;
    }
    auto output = std::make_shared<CreateNodesResult>();
    output->fromJsonString(resp.getResult()->getResponseBody());
    result.setSuccess(true);
    result.setResult(output);
    return result;
}

ResultData<VolcengineMetadata, DeleteAddonResult> VkeClient::DeleteAddon(const DeleteAddonRequest &input) const{
    ResultData<VolcengineMetadata, DeleteAddonResult> result;
    auto rb = client_->initBuilder(svc_);
    rb = input.withRequestBuilder(rb,"");
    auto headers = rb.getHeaders();
    headers["content-type"] = "application/json";
    rb.setHeaders(headers);

    auto content = std::make_shared<std::stringstream>();
    std::string body;
    if (!input.jsonPayload().empty()){
        body = input.jsonPayload().dump();
        *content << body;
    }else{
        content = nullptr;
    }

    auto req = rb.Build(MethodPost, content,body);
    auto resp = client_->doCall(req);
    result.setMetadata(resp.getMetadata());
    if (!resp.isSuccess()) {
        result.setSuccess(false);
        return result;
    }
    auto output = std::make_shared<DeleteAddonResult>();
    output->fromJsonString(resp.getResult()->getResponseBody());
    result.setSuccess(true);
    result.setResult(output);
    return result;
}

ResultData<VolcengineMetadata, DeleteClusterResult> VkeClient::DeleteCluster(const DeleteClusterRequest &input) const{
    ResultData<VolcengineMetadata, DeleteClusterResult> result;
    auto rb = client_->initBuilder(svc_);
    rb = input.withRequestBuilder(rb,"");
    auto headers = rb.getHeaders();
    headers["content-type"] = "application/json";
    rb.setHeaders(headers);

    auto content = std::make_shared<std::stringstream>();
    std::string body;
    if (!input.jsonPayload().empty()){
        body = input.jsonPayload().dump();
        *content << body;
    }else{
        content = nullptr;
    }

    auto req = rb.Build(MethodPost, content,body);
    auto resp = client_->doCall(req);
    result.setMetadata(resp.getMetadata());
    if (!resp.isSuccess()) {
        result.setSuccess(false);
        return result;
    }
    auto output = std::make_shared<DeleteClusterResult>();
    output->fromJsonString(resp.getResult()->getResponseBody());
    result.setSuccess(true);
    result.setResult(output);
    return result;
}

ResultData<VolcengineMetadata, DeleteKubeconfigsResult> VkeClient::DeleteKubeconfigs(const DeleteKubeconfigsRequest &input) const{
    ResultData<VolcengineMetadata, DeleteKubeconfigsResult> result;
    auto rb = client_->initBuilder(svc_);
    rb = input.withRequestBuilder(rb,"");
    auto headers = rb.getHeaders();
    headers["content-type"] = "application/json";
    rb.setHeaders(headers);

    auto content = std::make_shared<std::stringstream>();
    std::string body;
    if (!input.jsonPayload().empty()){
        body = input.jsonPayload().dump();
        *content << body;
    }else{
        content = nullptr;
    }

    auto req = rb.Build(MethodPost, content,body);
    auto resp = client_->doCall(req);
    result.setMetadata(resp.getMetadata());
    if (!resp.isSuccess()) {
        result.setSuccess(false);
        return result;
    }
    auto output = std::make_shared<DeleteKubeconfigsResult>();
    output->fromJsonString(resp.getResult()->getResponseBody());
    result.setSuccess(true);
    result.setResult(output);
    return result;
}

ResultData<VolcengineMetadata, DeleteNodePoolResult> VkeClient::DeleteNodePool(const DeleteNodePoolRequest &input) const{
    ResultData<VolcengineMetadata, DeleteNodePoolResult> result;
    auto rb = client_->initBuilder(svc_);
    rb = input.withRequestBuilder(rb,"");
    auto headers = rb.getHeaders();
    headers["content-type"] = "application/json";
    rb.setHeaders(headers);

    auto content = std::make_shared<std::stringstream>();
    std::string body;
    if (!input.jsonPayload().empty()){
        body = input.jsonPayload().dump();
        *content << body;
    }else{
        content = nullptr;
    }

    auto req = rb.Build(MethodPost, content,body);
    auto resp = client_->doCall(req);
    result.setMetadata(resp.getMetadata());
    if (!resp.isSuccess()) {
        result.setSuccess(false);
        return result;
    }
    auto output = std::make_shared<DeleteNodePoolResult>();
    output->fromJsonString(resp.getResult()->getResponseBody());
    result.setSuccess(true);
    result.setResult(output);
    return result;
}

ResultData<VolcengineMetadata, DeleteNodesResult> VkeClient::DeleteNodes(const DeleteNodesRequest &input) const{
    ResultData<VolcengineMetadata, DeleteNodesResult> result;
    auto rb = client_->initBuilder(svc_);
    rb = input.withRequestBuilder(rb,"");
    auto headers = rb.getHeaders();
    headers["content-type"] = "application/json";
    rb.setHeaders(headers);

    auto content = std::make_shared<std::stringstream>();
    std::string body;
    if (!input.jsonPayload().empty()){
        body = input.jsonPayload().dump();
        *content << body;
    }else{
        content = nullptr;
    }

    auto req = rb.Build(MethodPost, content,body);
    auto resp = client_->doCall(req);
    result.setMetadata(resp.getMetadata());
    if (!resp.isSuccess()) {
        result.setSuccess(false);
        return result;
    }
    auto output = std::make_shared<DeleteNodesResult>();
    output->fromJsonString(resp.getResult()->getResponseBody());
    result.setSuccess(true);
    result.setResult(output);
    return result;
}

ResultData<VolcengineMetadata, ForwardKubernetesApiResult> VkeClient::ForwardKubernetesApi(const ForwardKubernetesApiRequest &input) const{
    ResultData<VolcengineMetadata, ForwardKubernetesApiResult> result;
    auto rb = client_->initBuilder(svc_);
    rb = input.withRequestBuilder(rb,"");
    auto headers = rb.getHeaders();
    headers["content-type"] = "application/json";
    rb.setHeaders(headers);

    auto content = std::make_shared<std::stringstream>();
    std::string body;
    if (!input.jsonPayload().empty()){
        body = input.jsonPayload().dump();
        *content << body;
    }else{
        content = nullptr;
    }

    auto req = rb.Build(MethodPost, content,body);
    auto resp = client_->doCall(req);
    result.setMetadata(resp.getMetadata());
    if (!resp.isSuccess()) {
        result.setSuccess(false);
        return result;
    }
    auto output = std::make_shared<ForwardKubernetesApiResult>();
    output->fromJsonString(resp.getResult()->getResponseBody());
    result.setSuccess(true);
    result.setResult(output);
    return result;
}

ResultData<VolcengineMetadata, ListAddonsResult> VkeClient::ListAddons(const ListAddonsRequest &input) const{
    ResultData<VolcengineMetadata, ListAddonsResult> result;
    auto rb = client_->initBuilder(svc_);
    rb = input.withRequestBuilder(rb,"");
    auto headers = rb.getHeaders();
    headers["content-type"] = "application/json";
    rb.setHeaders(headers);

    auto content = std::make_shared<std::stringstream>();
    std::string body;
    if (!input.jsonPayload().empty()){
        body = input.jsonPayload().dump();
        *content << body;
    }else{
        content = nullptr;
    }

    auto req = rb.Build(MethodPost, content,body);
    auto resp = client_->doCall(req);
    result.setMetadata(resp.getMetadata());
    if (!resp.isSuccess()) {
        result.setSuccess(false);
        return result;
    }
    auto output = std::make_shared<ListAddonsResult>();
    output->fromJsonString(resp.getResult()->getResponseBody());
    result.setSuccess(true);
    result.setResult(output);
    return result;
}

ResultData<VolcengineMetadata, ListClustersResult> VkeClient::ListClusters(const ListClustersRequest &input) const{
    ResultData<VolcengineMetadata, ListClustersResult> result;
    auto rb = client_->initBuilder(svc_);
    rb = input.withRequestBuilder(rb,"");
    auto headers = rb.getHeaders();
    headers["content-type"] = "application/json";
    rb.setHeaders(headers);

    auto content = std::make_shared<std::stringstream>();
    std::string body;
    if (!input.jsonPayload().empty()){
        body = input.jsonPayload().dump();
        *content << body;
    }else{
        content = nullptr;
    }

    auto req = rb.Build(MethodPost, content,body);
    auto resp = client_->doCall(req);
    result.setMetadata(resp.getMetadata());
    if (!resp.isSuccess()) {
        result.setSuccess(false);
        return result;
    }
    auto output = std::make_shared<ListClustersResult>();
    output->fromJsonString(resp.getResult()->getResponseBody());
    result.setSuccess(true);
    result.setResult(output);
    return result;
}

ResultData<VolcengineMetadata, ListKubeconfigsResult> VkeClient::ListKubeconfigs(const ListKubeconfigsRequest &input) const{
    ResultData<VolcengineMetadata, ListKubeconfigsResult> result;
    auto rb = client_->initBuilder(svc_);
    rb = input.withRequestBuilder(rb,"");
    auto headers = rb.getHeaders();
    headers["content-type"] = "application/json";
    rb.setHeaders(headers);

    auto content = std::make_shared<std::stringstream>();
    std::string body;
    if (!input.jsonPayload().empty()){
        body = input.jsonPayload().dump();
        *content << body;
    }else{
        content = nullptr;
    }

    auto req = rb.Build(MethodPost, content,body);
    auto resp = client_->doCall(req);
    result.setMetadata(resp.getMetadata());
    if (!resp.isSuccess()) {
        result.setSuccess(false);
        return result;
    }
    auto output = std::make_shared<ListKubeconfigsResult>();
    output->fromJsonString(resp.getResult()->getResponseBody());
    result.setSuccess(true);
    result.setResult(output);
    return result;
}

ResultData<VolcengineMetadata, ListNodePoolsResult> VkeClient::ListNodePools(const ListNodePoolsRequest &input) const{
    ResultData<VolcengineMetadata, ListNodePoolsResult> result;
    auto rb = client_->initBuilder(svc_);
    rb = input.withRequestBuilder(rb,"");
    auto headers = rb.getHeaders();
    headers["content-type"] = "application/json";
    rb.setHeaders(headers);

    auto content = std::make_shared<std::stringstream>();
    std::string body;
    if (!input.jsonPayload().empty()){
        body = input.jsonPayload().dump();
        *content << body;
    }else{
        content = nullptr;
    }

    auto req = rb.Build(MethodPost, content,body);
    auto resp = client_->doCall(req);
    result.setMetadata(resp.getMetadata());
    if (!resp.isSuccess()) {
        result.setSuccess(false);
        return result;
    }
    auto output = std::make_shared<ListNodePoolsResult>();
    output->fromJsonString(resp.getResult()->getResponseBody());
    result.setSuccess(true);
    result.setResult(output);
    return result;
}

ResultData<VolcengineMetadata, ListNodesResult> VkeClient::ListNodes(const ListNodesRequest &input) const{
    ResultData<VolcengineMetadata, ListNodesResult> result;
    auto rb = client_->initBuilder(svc_);
    rb = input.withRequestBuilder(rb,"");
    auto headers = rb.getHeaders();
    headers["content-type"] = "application/json";
    rb.setHeaders(headers);

    auto content = std::make_shared<std::stringstream>();
    std::string body;
    if (!input.jsonPayload().empty()){
        body = input.jsonPayload().dump();
        *content << body;
    }else{
        content = nullptr;
    }

    auto req = rb.Build(MethodPost, content,body);
    auto resp = client_->doCall(req);
    result.setMetadata(resp.getMetadata());
    if (!resp.isSuccess()) {
        result.setSuccess(false);
        return result;
    }
    auto output = std::make_shared<ListNodesResult>();
    output->fromJsonString(resp.getResult()->getResponseBody());
    result.setSuccess(true);
    result.setResult(output);
    return result;
}

ResultData<VolcengineMetadata, ListSupportedAddonsResult> VkeClient::ListSupportedAddons(const ListSupportedAddonsRequest &input) const{
    ResultData<VolcengineMetadata, ListSupportedAddonsResult> result;
    auto rb = client_->initBuilder(svc_);
    rb = input.withRequestBuilder(rb,"");
    auto headers = rb.getHeaders();
    headers["content-type"] = "application/json";
    rb.setHeaders(headers);

    auto content = std::make_shared<std::stringstream>();
    std::string body;
    if (!input.jsonPayload().empty()){
        body = input.jsonPayload().dump();
        *content << body;
    }else{
        content = nullptr;
    }

    auto req = rb.Build(MethodPost, content,body);
    auto resp = client_->doCall(req);
    result.setMetadata(resp.getMetadata());
    if (!resp.isSuccess()) {
        result.setSuccess(false);
        return result;
    }
    auto output = std::make_shared<ListSupportedAddonsResult>();
    output->fromJsonString(resp.getResult()->getResponseBody());
    result.setSuccess(true);
    result.setResult(output);
    return result;
}

ResultData<VolcengineMetadata, ListSupportedResourceTypesResult> VkeClient::ListSupportedResourceTypes(const ListSupportedResourceTypesRequest &input) const{
    ResultData<VolcengineMetadata, ListSupportedResourceTypesResult> result;
    auto rb = client_->initBuilder(svc_);
    rb = input.withRequestBuilder(rb,"");
    auto headers = rb.getHeaders();
    headers["content-type"] = "application/json";
    rb.setHeaders(headers);

    auto content = std::make_shared<std::stringstream>();
    std::string body;
    if (!input.jsonPayload().empty()){
        body = input.jsonPayload().dump();
        *content << body;
    }else{
        content = nullptr;
    }

    auto req = rb.Build(MethodPost, content,body);
    auto resp = client_->doCall(req);
    result.setMetadata(resp.getMetadata());
    if (!resp.isSuccess()) {
        result.setSuccess(false);
        return result;
    }
    auto output = std::make_shared<ListSupportedResourceTypesResult>();
    output->fromJsonString(resp.getResult()->getResponseBody());
    result.setSuccess(true);
    result.setResult(output);
    return result;
}

ResultData<VolcengineMetadata, ListTagsForResourcesResult> VkeClient::ListTagsForResources(const ListTagsForResourcesRequest &input) const{
    ResultData<VolcengineMetadata, ListTagsForResourcesResult> result;
    auto rb = client_->initBuilder(svc_);
    rb = input.withRequestBuilder(rb,"");
    auto headers = rb.getHeaders();
    headers["content-type"] = "application/json";
    rb.setHeaders(headers);

    auto content = std::make_shared<std::stringstream>();
    std::string body;
    if (!input.jsonPayload().empty()){
        body = input.jsonPayload().dump();
        *content << body;
    }else{
        content = nullptr;
    }

    auto req = rb.Build(MethodPost, content,body);
    auto resp = client_->doCall(req);
    result.setMetadata(resp.getMetadata());
    if (!resp.isSuccess()) {
        result.setSuccess(false);
        return result;
    }
    auto output = std::make_shared<ListTagsForResourcesResult>();
    output->fromJsonString(resp.getResult()->getResponseBody());
    result.setSuccess(true);
    result.setResult(output);
    return result;
}

ResultData<VolcengineMetadata, TagResourcesResult> VkeClient::TagResources(const TagResourcesRequest &input) const{
    ResultData<VolcengineMetadata, TagResourcesResult> result;
    auto rb = client_->initBuilder(svc_);
    rb = input.withRequestBuilder(rb,"");
    auto headers = rb.getHeaders();
    headers["content-type"] = "application/json";
    rb.setHeaders(headers);

    auto content = std::make_shared<std::stringstream>();
    std::string body;
    if (!input.jsonPayload().empty()){
        body = input.jsonPayload().dump();
        *content << body;
    }else{
        content = nullptr;
    }

    auto req = rb.Build(MethodPost, content,body);
    auto resp = client_->doCall(req);
    result.setMetadata(resp.getMetadata());
    if (!resp.isSuccess()) {
        result.setSuccess(false);
        return result;
    }
    auto output = std::make_shared<TagResourcesResult>();
    output->fromJsonString(resp.getResult()->getResponseBody());
    result.setSuccess(true);
    result.setResult(output);
    return result;
}

ResultData<VolcengineMetadata, UntagResourcesResult> VkeClient::UntagResources(const UntagResourcesRequest &input) const{
    ResultData<VolcengineMetadata, UntagResourcesResult> result;
    auto rb = client_->initBuilder(svc_);
    rb = input.withRequestBuilder(rb,"");
    auto headers = rb.getHeaders();
    headers["content-type"] = "application/json";
    rb.setHeaders(headers);

    auto content = std::make_shared<std::stringstream>();
    std::string body;
    if (!input.jsonPayload().empty()){
        body = input.jsonPayload().dump();
        *content << body;
    }else{
        content = nullptr;
    }

    auto req = rb.Build(MethodPost, content,body);
    auto resp = client_->doCall(req);
    result.setMetadata(resp.getMetadata());
    if (!resp.isSuccess()) {
        result.setSuccess(false);
        return result;
    }
    auto output = std::make_shared<UntagResourcesResult>();
    output->fromJsonString(resp.getResult()->getResponseBody());
    result.setSuccess(true);
    result.setResult(output);
    return result;
}

ResultData<VolcengineMetadata, UpdateAddonConfigResult> VkeClient::UpdateAddonConfig(const UpdateAddonConfigRequest &input) const{
    ResultData<VolcengineMetadata, UpdateAddonConfigResult> result;
    auto rb = client_->initBuilder(svc_);
    rb = input.withRequestBuilder(rb,"");
    auto headers = rb.getHeaders();
    headers["content-type"] = "application/json";
    rb.setHeaders(headers);

    auto content = std::make_shared<std::stringstream>();
    std::string body;
    if (!input.jsonPayload().empty()){
        body = input.jsonPayload().dump();
        *content << body;
    }else{
        content = nullptr;
    }

    auto req = rb.Build(MethodPost, content,body);
    auto resp = client_->doCall(req);
    result.setMetadata(resp.getMetadata());
    if (!resp.isSuccess()) {
        result.setSuccess(false);
        return result;
    }
    auto output = std::make_shared<UpdateAddonConfigResult>();
    output->fromJsonString(resp.getResult()->getResponseBody());
    result.setSuccess(true);
    result.setResult(output);
    return result;
}

ResultData<VolcengineMetadata, UpdateAddonVersionResult> VkeClient::UpdateAddonVersion(const UpdateAddonVersionRequest &input) const{
    ResultData<VolcengineMetadata, UpdateAddonVersionResult> result;
    auto rb = client_->initBuilder(svc_);
    rb = input.withRequestBuilder(rb,"");
    auto headers = rb.getHeaders();
    headers["content-type"] = "application/json";
    rb.setHeaders(headers);

    auto content = std::make_shared<std::stringstream>();
    std::string body;
    if (!input.jsonPayload().empty()){
        body = input.jsonPayload().dump();
        *content << body;
    }else{
        content = nullptr;
    }

    auto req = rb.Build(MethodPost, content,body);
    auto resp = client_->doCall(req);
    result.setMetadata(resp.getMetadata());
    if (!resp.isSuccess()) {
        result.setSuccess(false);
        return result;
    }
    auto output = std::make_shared<UpdateAddonVersionResult>();
    output->fromJsonString(resp.getResult()->getResponseBody());
    result.setSuccess(true);
    result.setResult(output);
    return result;
}

ResultData<VolcengineMetadata, UpdateClusterConfigResult> VkeClient::UpdateClusterConfig(const UpdateClusterConfigRequest &input) const{
    ResultData<VolcengineMetadata, UpdateClusterConfigResult> result;
    auto rb = client_->initBuilder(svc_);
    rb = input.withRequestBuilder(rb,"");
    auto headers = rb.getHeaders();
    headers["content-type"] = "application/json";
    rb.setHeaders(headers);

    auto content = std::make_shared<std::stringstream>();
    std::string body;
    if (!input.jsonPayload().empty()){
        body = input.jsonPayload().dump();
        *content << body;
    }else{
        content = nullptr;
    }

    auto req = rb.Build(MethodPost, content,body);
    auto resp = client_->doCall(req);
    result.setMetadata(resp.getMetadata());
    if (!resp.isSuccess()) {
        result.setSuccess(false);
        return result;
    }
    auto output = std::make_shared<UpdateClusterConfigResult>();
    output->fromJsonString(resp.getResult()->getResponseBody());
    result.setSuccess(true);
    result.setResult(output);
    return result;
}

ResultData<VolcengineMetadata, UpdateNodePoolConfigResult> VkeClient::UpdateNodePoolConfig(const UpdateNodePoolConfigRequest &input) const{
    ResultData<VolcengineMetadata, UpdateNodePoolConfigResult> result;
    auto rb = client_->initBuilder(svc_);
    rb = input.withRequestBuilder(rb,"");
    auto headers = rb.getHeaders();
    headers["content-type"] = "application/json";
    rb.setHeaders(headers);

    auto content = std::make_shared<std::stringstream>();
    std::string body;
    if (!input.jsonPayload().empty()){
        body = input.jsonPayload().dump();
        *content << body;
    }else{
        content = nullptr;
    }

    auto req = rb.Build(MethodPost, content,body);
    auto resp = client_->doCall(req);
    result.setMetadata(resp.getMetadata());
    if (!resp.isSuccess()) {
        result.setSuccess(false);
        return result;
    }
    auto output = std::make_shared<UpdateNodePoolConfigResult>();
    output->fromJsonString(resp.getResult()->getResponseBody());
    result.setSuccess(true);
    result.setResult(output);
    return result;
}
